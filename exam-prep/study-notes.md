## Vault Associate (003) Prep
- https://developer.hashicorp.com/vault/tutorials/associate-cert-003/associate-questions-003


- Batch tokens cannot be renewed idenfinitely.

---

<details>

<summary>Batch tokens cannot be renewed indefinitely.</summary>

### Batch tokens cannot be renewed indefinitely.

- [Vault Tokens](https://developer.hashicorp.com/vault/docs/concepts/tokens)

</details>

Orphan tokens does not expire when its parent does.
- It is not persisted
- It doesn't have a max time-to-live (TTL)
- It has a use limit

- [Vault Tokens](https://developer.hashicorp.com/vault/docs/concepts/tokens)

### Which path will this policy allow?
```
path "kv/+/team_*" {
    capabilities = ["read"]
}
```

- [ ] `kv/team_edu`
- [ ] `kv/us-west/team`
- [ ] `kv/us-west/team_edu`
- [ ] `kv/us-west/ca/team_edu`

<details>
<summary>ANSWER</summary>

```
path "kv/+/team_*" {
    capabilities = ["read"]
}
```

```diff
# It would not show as it is a direct path from kv and misses the kv/+/ requirement
- kv/team_edu

# It would not show as it is missing the team_
- kv/us-west/team

# It would show as it meets all path requirements
+ kv/us-west/team_edu

# It would not show as it has an additional path requirement
- kv/us-west/ca/team_edu
```

Source: [Vault Policies](https://developer.hashicorp.com/vault/docs/concepts/policies)
</details>

---
### An organization needs to protect sensitive application data currently stored in a database as plaintext. Which secrets engine provides a solution?

- [ ] `Key/Value v2 secrets engine`
- [ ] `Cubbyhole secrets engine`
- [ ] `Transit secrets engine`
- [ ] `Database secrets engine`

<details>
<summary>ANSWER</summary>

```diff
- [ ] `Key/Value v2 secrets engine`
- [ ] `Cubbyhole secrets engine`
+ [x] `Transit secrets engine`
- [ ] `Database secrets engine`
```
Source: [Vault Transit Secrets Engine](https://developer.hashicorp.com/vault/docs/secrets/transit)
</details>

### Based on the token lookup output, what type of token is it?

```shell
$ vault token lookup
Key                 Value
---                 -----
accessor            n/a
creation_time       1646698338
creation_ttl        20m
display_name        token
entity_id           n/a
expire_time         2022-03-07T16:32:18-08:00
explicit_max_ttl    0s
id                  hvb.AAAAAQJyBEVE-vTWUrg0hcoIPuvKjjNxXXZ5MfsYVg2gJ0fGZpVi0IGTFfh4TqsoQIWaocNRXD1qzGXvhIHWJBM_rWU9YJY8sXOYVy_s1JAHasXJwGmZ_fBLJfSG6aCwQkCGwtAhYw
issue_time          2022-03-07T16:12:18-08:00
meta                <nil>
num_uses            0
orphan              false
path                auth/token/create
policies            [default test]
renewable           false
ttl                 13m58s
type                batch
```

- [ ] root
- [ ] batch
- [ ] orphan
- [ ] periodic

<details>
<summary>ANSWER</summary>

```diff
- [ ] root
+ [x] batch
- [ ] orphan
- [ ] periodic
```
> [!TIP]
> Make sure to look at all attributes that are returned in the token lookup. The prefix also reveals the quick token type `hvb.`


Source: [Vault Tokens](https://developer.hashicorp.com/vault/docs/concepts/tokens)
</details>

---
### Based on the token lookup output, how many times can the token be used?

```shell
$ vault token lookup
Key                 Value
---                 -----
accessor            GMAlk9ZNLGOCuTrOEIAooJG3
creation_time       1646691009
creation_ttl        1h
display_name        token
entity_id           n/a
expire_time         2022-03-07T15:10:09.115115-08:00
explicit_max_ttl    0s
id                  hvs.CAESIJRM-T1q5lEjIWux1Tjx-VGqAYJdd4FZtbp1wpD5Ym9pGh4KHGh2cy5TSjRndGoxaU44NzNscm5MSlRLQXZ0ZGg
issue_time          2022-03-07T14:10:09.115118-08:00
meta                <nil>
num_uses            1
orphan              false
path                auth/token/create
policies            [default]
renewable           true
ttl                 58m14s
type                service
```

- [ ] Until the TTL expires in 58m14s
- [ ] 1 time
- [ ] The token has expired because max TTL is already at 0s
- [ ] This token does not expire because the `default` policy is attached

<details>
<summary>ANSWER</summary>

```diff
- [ ] Until the TTL expires in 58m14s
+ [x] 1 time
- [ ] The token has expired because max TTL is already at 0s
- [ ] This token does not expire because the `default` policy is attached
```
> [!TIP]
> Make sure to look at all attributes that are returned in the token lookup. The prefix also reveals the quick token type `hvb.`


Source: [Vault Tokens](https://developer.hashicorp.com/vault/docs/concepts/tokens)
</details>

### What is true of Vault tokens? Pick the 2 correct responses below
- [ ] Vault tokens are generated by every authentication method login
- [ ] Vault tokens are also known as unseal keys
- [ ] Vault tokens are required for every Vault call
- [ ] Vault token IDs always begin with "s." such as `s.E7rOurS2n7m2Dt5409jWxR87`
- [ ] Vault tokens are the core method for authentication in Vault
<details>
<summary>ANSWER</summary>

```diff
+ [x] Vault tokens are generated by every authentication method login
- [ ] Vault tokens are also known as unseal keys
- [ ] Vault tokens are required for every Vault call
- [ ] Vault token IDs always begin with "s." such as `s.E7rOurS2n7m2Dt5409jWxR87`
+ [x] Vault tokens are the core method for authentication in Vault
```

Source: [Vault Tokens](https://developer.hashicorp.com/vault/docs/concepts/tokens)
</details>


### Which statements correctly describe the command below. Pick the 2 correct responses below
```shell
vault write transit/decrypt/password \
  ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==

```
<details>
<summary>ANSWER</summary>

```diff
- [ ] Returns an error due to missing encryption key name
+ [x] Returns base64-encoded plaintext
+ [x] Decrypts the ciphertext if the token permits
- [ ] Returns the ciphertext
- [ ] Requires `sudo` capability on the `transit/decrypt/password` path
```

Source: [Vault Transit Secrets Engine](https://developer.hashicorp.com/vault/docs/secrets/transit)
</details>

---
### Which of the following statements explains the benefit of response wrapping? Pick the 2 correct responses below
- [ ] Limits the time of secret exposure by having a short-lived wrapping token
- [ ] Allow versioning of the secrets
- [ ] It protects Vault's root key (previously known as master key)
- [ ] Only the reference to the secrets is transmitted over the public network
- [ ] Limits the size of secrets to be transmitted over the network
<details>
<summary>ANSWER</summary>

```diff
+ [x] Limits the time of secret exposure by having a short-lived wrapping token
- [ ] Allow versioning of the secrets
- [ ] It protects Vault's root key (previously known as master key)
+ [x] Only the reference to the secrets is transmitted over the public network
- [ ] Limits the size of secrets to be transmitted over the network
```

Source: [Vault Response Wrapping](https://developer.hashicorp.com/vault/docs/concepts/response-wrapping)

> [!NOTE]
> Response-wrapping feature: When requested, Vault can take the response it would have sent to an HTTP client and instead insert it into the `cubbyhole` of a single-use token, returning that single-use token instead.
> Logically speaking, the response is wrapped by the token, and retrieving it requires an unwrap operation against this token.
> Functionally speaking, the token provides authorization to use an encryption key from Vault's keyring to decrypt the data.

Response wrapping is a powerful mechanism for information sharing in many environments. Often the best practical option is to provide `cover` for the secret information, be able to `detect malfeasance` (interception, tampering), and `limit lifetime` of the secret's exposure.

Response wrapping performs all three of these duties:
- "Cover": Ensures that values being transmitted across the wire is not the actual secret but a reference to such a secret, namely the response-wrapping token. Information stored in logs or captured along the way do not directly see the sensitive information.
- "Malfeasance Detection": Ensures that only a single party can ever unwrap the token and see what's inside. A client receiving a token that cannot be unwrapped can trigger an immediate security incident. In addition, a client can inspect a given token before unwrapping to ensure that its origin is from the expected location in Vault.
- "Limited Lifetime": Ensures that secret exposure is limited because the response-wrapping token has a lifetime that is separate from the wrapped secret (and often can be much shorter), so if a client fails to come up and unwrap the token, the token can expire very quickly.

### Response-wrapping tokens
When a response is wrapped, the normal API response from Vault does not contain the original secret, but rather contains a set of information related to the response-wrapping token:
- TTL: TTL of the response-wrapping token itself
- Token: the actual token value
- Creation Time: the time that the response-wrapping token was created
- Creation Path: the API path that was called in the original request
- Wrapped Accessor: if the wrapped response is an authentication response containing a Vault token, this is the value of the wrapped token's accessor. This is useful for orchestration systems (such as Nomad) to be able to control the lifetime of secrets based on their knowledge of the lifetime of jobs, without having to actually unwrap the response-wrapping token or gain knowledge of the token ID inside.

Doesn't yet support `signed response-wrapping tokens`, as it provides little extra protection.

`Why not?`
- If you are pointed to the correct Vault server, token validation is performed by interacting with the server itself. A signed token doesn't remove the need to validate the token with the server, since the token is not carrying data but merely an access mechanism and the server will not release data without validating it.
- If you are being attacked and pointed to the wrong Vault server, the same attacker could trivially give you the wrong signing public key that corresponds to the wrong Vault server.
- You could cache a previously valid key, but could also cache a previously valid address (and in most cases the Vault address will not change or will be set via a service discovery mechanism). As such, we rely on the fact that the token itself is not carrying authoritative data and do not sign it.

### Response-wrapping token operations
Path: `sys/wrapping`
- `sys/wrapping/lookup`: Fetch the response-wrapping token's creation time, creation path, and TTL. This is an unauthenticated path and available to response-wrapping tokens themselves. A response-wrapping token holder wishing to perform validation is always allowed to look up the properties of the token.
- `sys/wrapping/unwrap`: Unwraps the token, returning the response inside. The response that is returned will be the original wire-format response; it can be used direclty with API clients.
- `sys/wrapping/rewrap`: Allows migrating the wrapped data to a new response-wrapping token. This can be useful for long-lived secrets. For example, an organization may wish (or be required in a compliance scenario) to have the `pki` backend's root CA key be returned in a long-lived reponse-wrapping token to ensure that nobody has seen the key (easily verified by performing lookups on the response-wrapping token) but available for signing CRLs in case they ever accidentally change or lose the `pki` mount. Often, compliance schemes require periodic rotation of secrets, so this helps achieve that compliance goals without actually exposing what's inside.
- `sys/wrapping/wrap`: Helper endpoint that echoes back the data sent to it in a response-wrapping token. Note that blocking access to this endpoint does not remove the ability for arbitrary data to be wrapped, as it can be done elsewhere in Vault.
</details>

---
### Your organization has recently adopted Vault open source. You have been asked to enable the Vault K/V Version 2 secrets engine by two different teams. Company policy states the teams can not share the same secrets engine. What are two possible solutions? Pick the 2 correct responses below
- [ ] Enable the secrets engine at a dedicated path for each team using the -path parameter
- [ ] Create a namespace for each of the teams and enable the secrets engine in the teams namespace
- [ ] Only one type of secrets engine can be enabled on a Vault cluster
- [ ] Deploy a second Vault cluster, one for each team
- [ ] Enable the secrets engine at the default path and create policies that limit what each team can list, read, and write
<details>
<summary>ANSWER</summary>

```diff
+ [x] Enable the secrets engine at a dedicated path for each team using the -path parameter
- [ ] Create a namespace for each of the teams and enable the secrets engine in the teams namespace
- [ ] Only one type of secrets engine can be enabled on a Vault cluster
+ [x] Deploy a second Vault cluster, one for each team
- [ ] Enable the secrets engine at the default path and create policies that limit what each team can list, read, and write
```

Source:
- [Vault secrets enable](https://developer.hashicorp.com/vault/docs/commands/secrets/enable)
- [Vault Enterprise Namespaces](https://developer.hashicorp.com/vault/docs/enterprise/namespaces)
</details>

